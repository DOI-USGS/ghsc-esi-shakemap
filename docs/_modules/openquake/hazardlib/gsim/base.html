
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>openquake.hazardlib.gsim.base &#8212; ShakeMap Documentation  documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for openquake.hazardlib.gsim.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2012-2020 GEM Foundation</span>
<span class="c1">#</span>
<span class="c1"># OpenQuake is free software: you can redistribute it and/or modify it</span>
<span class="c1"># under the terms of the GNU Affero General Public License as published</span>
<span class="c1"># by the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># OpenQuake is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Affero General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Affero General Public License</span>
<span class="c1"># along with OpenQuake. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module :mod:`openquake.hazardlib.gsim.base` defines base classes for</span>
<span class="sd">different kinds of :class:`ground shaking intensity models</span>
<span class="sd">&lt;GroundShakingIntensityModel&gt;`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">ndtr</span>

<span class="kn">from</span> <span class="nn">openquake.hazardlib.stats</span> <span class="kn">import</span> <span class="n">norm_cdf</span>
<span class="kn">from</span> <span class="nn">openquake.baselib.general</span> <span class="kn">import</span> <span class="ne">DeprecationWarning</span>
<span class="kn">from</span> <span class="nn">openquake.hazardlib</span> <span class="kn">import</span> <span class="n">imt</span> <span class="k">as</span> <span class="n">imt_module</span>
<span class="kn">from</span> <span class="nn">openquake.hazardlib</span> <span class="kn">import</span> <span class="n">const</span>
<span class="kn">from</span> <span class="nn">openquake.hazardlib.contexts</span> <span class="kn">import</span> <span class="n">KNOWN_DISTANCES</span>
<span class="kn">from</span> <span class="nn">openquake.hazardlib.contexts</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># for backward compatibility</span>


<span class="n">ADMITTED_STR_PARAMETERS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DEFINED_FOR_TECTONIC_REGION_TYPE&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;DEFINED_FOR_INTENSITY_MEASURE_COMPONENT&#39;</span><span class="p">]</span>
<span class="n">ADMITTED_FLOAT_PARAMETERS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DEFINED_FOR_REFERENCE_VELOCITY&#39;</span><span class="p">]</span>
<span class="n">ADMITTED_TABLE_PARAMETERS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;COEFFS_STRESS&#39;</span><span class="p">,</span> <span class="s1">&#39;COEFFS_HARD_ROCK&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;COEFFS_SITE_RESPONSE&#39;</span><span class="p">]</span>
<span class="n">ADMITTED_SET_PARAMETERS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DEFINED_FOR_INTENSITY_MEASURE_TYPES&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;DEFINED_FOR_STANDARD_DEVIATION_TYPES&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;REQUIRES_DISTANCES&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;REQUIRES_SITES_PARAMETERS&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;REQUIRES_RUPTURE_PARAMETERS&#39;</span><span class="p">]</span>

<span class="n">registry</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># GSIM name -&gt; GSIM class</span>
<span class="n">gsim_aliases</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># populated for instance in nbcc2015_AA13.py</span>


<span class="k">class</span> <span class="nc">NotVerifiedWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised when a non verified GSIM is instantiated</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ExperimentalWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised for GMPEs that are intended for experimental use or maybe subject</span>
<span class="sd">    to changes in future version.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">AdaptedWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised for GMPEs that are intended for experimental use or maybe subject</span>
<span class="sd">    to changes in future version.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">gsim_imt_dt</span><span class="p">(</span><span class="n">sorted_gsims</span><span class="p">,</span> <span class="n">sorted_imts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a numpy dtype as a nested record with keys &#39;idx&#39; and nested</span>
<span class="sd">    (gsim, imt).</span>

<span class="sd">    :param sorted_gsims: a list of GSIM instances, sorted lexicographically</span>
<span class="sd">    :param sorted_imts: a list of intensity measure type strings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtlist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imt</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">imt</span> <span class="ow">in</span> <span class="n">sorted_imts</span><span class="p">]</span>
    <span class="n">imt_dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtlist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="nb">str</span><span class="p">(</span><span class="n">gsim</span><span class="p">),</span> <span class="n">imt_dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">gsim</span> <span class="ow">in</span> <span class="n">sorted_gsims</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">get_poes</span><span class="p">(</span><span class="n">mean_std</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">,</span> <span class="n">gsims</span><span class="o">=</span><span class="p">(),</span> <span class="n">af</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sitecode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rrup</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate and return probabilities of exceedance (PoEs) of one or more</span>
<span class="sd">    intensity measure levels (IMLs) of one intensity measure type (IMT)</span>
<span class="sd">    for one or more pairs &quot;site -- rupture&quot;.</span>

<span class="sd">    :param mean_std:</span>
<span class="sd">        An array of shape (2, N, M, G) with mean and standard deviation for</span>
<span class="sd">        the current intensity measure type</span>
<span class="sd">    :param loglevels:</span>
<span class="sd">        A DictArray imt -&gt; logs of intensity measure levels</span>
<span class="sd">    :param truncation_level:</span>
<span class="sd">        Can be ``None``, which means that the distribution of intensity</span>
<span class="sd">        is treated as Gaussian distribution with possible values ranging</span>
<span class="sd">        from minus infinity to plus infinity.</span>

<span class="sd">        When set to zero, the mean intensity is treated as an exact</span>
<span class="sd">        value (standard deviation is not even computed for that case)</span>
<span class="sd">        and resulting array contains 0 in places where IMT is strictly</span>
<span class="sd">        lower than the mean value of intensity and 1.0 where IMT is equal</span>
<span class="sd">        or greater.</span>

<span class="sd">        When truncation level is positive number, the intensity</span>
<span class="sd">        distribution is processed as symmetric truncated Gaussian with</span>
<span class="sd">        range borders being ``mean - truncation_level * stddev`` and</span>
<span class="sd">        ``mean + truncation_level * stddev``. That is, the truncation</span>
<span class="sd">        level expresses how far the range borders are from the mean</span>
<span class="sd">        value and is defined in units of sigmas. The resulting PoEs</span>
<span class="sd">        for that mode are values of complementary cumulative distribution</span>
<span class="sd">        function of that truncated Gaussian applied to IMLs.</span>

<span class="sd">    :returns:</span>
<span class="sd">        array of PoEs of shape (N, L, G)</span>

<span class="sd">    :raises ValueError:</span>
<span class="sd">        If truncation level is not ``None`` and neither non-negative</span>
<span class="sd">        float number, and if ``imts`` dictionary contain wrong or</span>
<span class="sd">        unsupported IMTs (see :attr:`DEFINED_FOR_INTENSITY_MEASURE_TYPES`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">truncation_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">truncation_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;truncation level must be zero, positive number &#39;</span>
                         <span class="s1">&#39;or None&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gsims</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">mean_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gsims</span><span class="p">)</span>
    <span class="n">tl</span> <span class="o">=</span> <span class="n">truncation_level</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">gsim</span><span class="p">,</span> <span class="s1">&#39;weights_signs&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">gsim</span> <span class="ow">in</span> <span class="n">gsims</span><span class="p">):</span>
        <span class="c1"># implement average get_poes for the nshmp_2014 model</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mean_std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (N, M, G)</span>
        <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loglevels</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>  <span class="c1"># L</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gsim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gsims</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">gsim</span><span class="p">,</span> <span class="s1">&#39;weights_signs&#39;</span><span class="p">):</span>
                <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">weights</span><span class="p">,</span> <span class="n">signs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">gsim</span><span class="o">.</span><span class="n">weights_signs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signs</span><span class="p">:</span>
                    <span class="n">ms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">])</span>  <span class="c1"># make a copy</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loglevels</span><span class="p">)):</span>
                        <span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">gsim</span><span class="o">.</span><span class="n">adjustment</span>
                    <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_poes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ms</span> <span class="o">=</span> <span class="n">mean_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span>
                <span class="n">arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_poes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;mixture_model&quot;</span> <span class="ow">in</span> <span class="n">gsim</span><span class="o">.</span><span class="n">kwargs</span> <span class="k">for</span> <span class="n">gsim</span> <span class="ow">in</span> <span class="n">gsims</span><span class="p">):</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mean_std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (N, M, G)</span>
        <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loglevels</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>  <span class="c1"># L</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gsim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gsims</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;mixture_model&quot;</span> <span class="ow">in</span> <span class="n">gsim</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fact</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                        <span class="n">gsim</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mixture_model&quot;</span><span class="p">][</span><span class="s2">&quot;factors&quot;</span><span class="p">],</span>
                        <span class="n">gsim</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mixture_model&quot;</span><span class="p">][</span><span class="s2">&quot;weights&quot;</span><span class="p">]):</span>
                    <span class="n">mean_stdi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">])</span>  <span class="c1"># a copy</span>
                    <span class="n">mean_stdi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fact</span>
                    <span class="n">arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">wgt</span> <span class="o">*</span> <span class="n">_get_poes</span><span class="p">(</span><span class="n">mean_stdi</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span>
                                                     <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ms</span> <span class="o">=</span> <span class="n">mean_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span>
                <span class="n">arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_poes</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">elif</span> <span class="n">af</span><span class="p">:</span>
        <span class="c1"># kernel amplification function</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_get_poes_site</span><span class="p">(</span><span class="n">mean_std</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">,</span> <span class="n">af</span><span class="p">,</span>
                             <span class="n">mag</span><span class="p">,</span> <span class="n">sitecode</span><span class="p">,</span> <span class="n">rrup</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># regular case</span>
        <span class="k">return</span> <span class="n">_get_poes</span><span class="p">(</span><span class="n">mean_std</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">)</span>


<span class="c1"># this is the critical function for the performance of the classical calculator</span>
<span class="c1"># it is dominated by memory allocations (i.e. _truncnorm_sf is ultra-fast)</span>
<span class="c1"># the only way to speedup is to reduce the maximum_distance, then the array</span>
<span class="c1"># will become shorter in the N dimension (number of affected sites), or to</span>
<span class="c1"># collapse the ruptures, then _get_poes will be called less times</span>
<span class="k">def</span> <span class="nf">_get_poes</span><span class="p">(</span><span class="n">mean_std</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">stddev</span> <span class="o">=</span> <span class="n">mean_std</span>  <span class="c1"># shape (N, M, G) each</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">loglevels</span><span class="o">.</span><span class="n">array</span><span class="p">),</span> <span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span> <span class="k">if</span> <span class="n">squeeze</span> <span class="k">else</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">G</span><span class="p">))</span>
    <span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">imt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loglevels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">iml</span> <span class="ow">in</span> <span class="n">loglevels</span><span class="p">[</span><span class="n">imt</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">truncation_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># just compare imls to mean</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="n">lvl</span><span class="p">]</span> <span class="o">=</span> <span class="n">iml</span> <span class="o">&lt;=</span> <span class="n">mean</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="n">lvl</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">iml</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[:,</span> <span class="n">m</span><span class="p">])</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
            <span class="n">lvl</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">_truncnorm_sf</span><span class="p">(</span><span class="n">truncation_level</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_poes_site</span><span class="p">(</span><span class="n">mean_std</span><span class="p">,</span> <span class="n">loglevels</span><span class="p">,</span> <span class="n">truncation_level</span><span class="p">,</span> <span class="n">ampfun</span><span class="p">,</span>
                   <span class="n">mag</span><span class="p">,</span> <span class="n">sitecode</span><span class="p">,</span> <span class="n">rrup</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NOTE: this works for a single site</span>

<span class="sd">    :param mean_std:</span>
<span class="sd">        See :function:`openquake.hazardlib.gsim.base.get_poes`</span>
<span class="sd">    :param loglevels:</span>
<span class="sd">        Intensity measure level per intensity measure type. See</span>
<span class="sd">        :function:`openquake.hazardlib.gsim.base.get_poes`</span>
<span class="sd">    :param truncation_level:</span>
<span class="sd">        The level of truncation of the normal distribution of ground-motion</span>
<span class="sd">        on rock</span>
<span class="sd">    :param ampl:</span>
<span class="sd">        Site amplification function instance of</span>
<span class="sd">        :class:openquake.hazardlib.site_amplification.AmpFunction</span>
<span class="sd">    :param mag:</span>
<span class="sd">        The magnitude of the earthquake</span>
<span class="sd">    :param rrup:</span>
<span class="sd">        The rrup distances</span>
<span class="sd">    :param squeeze:</span>
<span class="sd">        A boolean. Should be True when ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Mean and std of ground motion for the IMTs considered in this analysis</span>
    <span class="c1"># N  - Number of sites</span>
    <span class="c1"># L - Number of intensity measure levels</span>
    <span class="c1"># G  - Number of GMMs</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">stddev</span> <span class="o">=</span> <span class="n">mean_std</span>  <span class="c1"># shape (N, M, G)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">loglevels</span><span class="o">.</span><span class="n">array</span><span class="p">),</span> <span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loglevels</span><span class="p">)</span>
    <span class="n">L1</span> <span class="o">=</span> <span class="n">L</span> <span class="o">//</span> <span class="n">M</span>

    <span class="c1"># This is the array where we store the output results i.e. poes on soil</span>
    <span class="n">out_s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span> <span class="k">if</span> <span class="n">squeeze</span> <span class="k">else</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">G</span><span class="p">))</span>

    <span class="c1"># `nsamp` is the number of IMLs per IMT used to compute the hazard on rock</span>
    <span class="c1"># while &#39;L&#39; is total number of ground-motion values</span>
    <span class="n">nsamp</span> <span class="o">=</span> <span class="mi">40</span>

    <span class="c1"># Compute the probability of exceedance for each in intensity</span>
    <span class="c1"># measure type IMT</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">ampfun</span><span class="o">.</span><span class="n">get_max_sigma</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">imt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loglevels</span><span class="p">):</span>

        <span class="c1"># Get the values of ground-motion used to compute the probability of</span>
        <span class="c1"># exceedance on soil.</span>
        <span class="n">soillevels</span> <span class="o">=</span> <span class="n">loglevels</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span>

        <span class="c1"># Here we set automatically the IMLs that will be used to compute</span>
        <span class="c1"># the probability of occurrence of GM on rock within discrete</span>
        <span class="c1"># intervals</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">soillevels</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="mf">4.</span><span class="p">,</span>
                            <span class="nb">max</span><span class="p">(</span><span class="n">soillevels</span><span class="p">)</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="mf">4.</span><span class="p">,</span>
                            <span class="n">num</span><span class="o">=</span><span class="n">nsamp</span><span class="p">)</span>

        <span class="c1"># Calculate for each ground motion interval the probability</span>
        <span class="c1"># of occurrence on rock for all the sites</span>
        <span class="k">for</span> <span class="n">iml_l</span><span class="p">,</span> <span class="n">iml_u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ll</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ll</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>

            <span class="c1"># Set the arguments of the truncated normal distribution</span>
            <span class="c1"># function</span>
            <span class="k">if</span> <span class="n">truncation_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">out_l</span> <span class="o">=</span> <span class="n">iml_l</span> <span class="o">&lt;=</span> <span class="n">mean</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
                <span class="n">out_u</span> <span class="o">=</span> <span class="n">iml_u</span> <span class="o">&lt;=</span> <span class="n">mean</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">iml_l</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[:,</span> <span class="n">m</span><span class="p">])</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
                <span class="n">out_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">iml_u</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[:,</span> <span class="n">m</span><span class="p">])</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>

            <span class="c1"># Probability of occurrence on rock - The shape of this array</span>
            <span class="c1"># is: number of sites x number of IMLs x GMMs. This corresponds</span>
            <span class="c1"># to 1 x 1 x number of GMMs</span>
            <span class="n">pocc_rock</span> <span class="o">=</span> <span class="p">(</span><span class="n">_truncnorm_sf</span><span class="p">(</span><span class="n">truncation_level</span><span class="p">,</span> <span class="n">out_l</span><span class="p">)</span> <span class="o">-</span>
                         <span class="n">_truncnorm_sf</span><span class="p">(</span><span class="n">truncation_level</span><span class="p">,</span> <span class="n">out_u</span><span class="p">))</span>

            <span class="c1"># Skipping cases where the pocc on rock is negligible</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pocc_rock</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Ground-motion value in the middle of each interval</span>
            <span class="n">iml_mid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iml_l</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iml_u</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

            <span class="c1"># Get mean and std of the amplification function for this</span>
            <span class="c1"># magnitude, distance and IML</span>
            <span class="n">median_af</span><span class="p">,</span> <span class="n">std_af</span> <span class="o">=</span> <span class="n">ampfun</span><span class="o">.</span><span class="n">get_mean_std</span><span class="p">(</span>
                <span class="n">sitecode</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iml_mid</span><span class="p">),</span> <span class="n">mag</span><span class="p">,</span> <span class="n">rrup</span><span class="p">)</span>

            <span class="c1"># Computing the probability of exceedance of the levels of</span>
            <span class="c1"># ground-motion loglevels on soil</span>
            <span class="n">logaf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">soillevels</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">iml_mid</span><span class="p">))</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">norm_cdf</span><span class="p">(</span><span class="n">logaf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">median_af</span><span class="p">),</span> <span class="n">std_af</span><span class="p">)</span>
            <span class="n">poex_af</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">logaf</span><span class="p">)))</span>
            <span class="c1"># The probability of occurrence on rock has shape:</span>
            <span class="c1"># 1 x 1 x number of GMMs</span>
            <span class="n">poex</span> <span class="o">=</span> <span class="n">poex_af</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">pocc_rock</span>

            <span class="c1"># Updating output</span>
            <span class="n">out_s</span><span class="p">[:,</span> <span class="n">m</span> <span class="o">*</span> <span class="n">L1</span><span class="p">:</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">poex</span>

    <span class="k">return</span> <span class="n">out_s</span>


<span class="k">class</span> <span class="nc">MetaGSIM</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metaclass converting set class attributes into frozensets, to avoid</span>
<span class="sd">    mutability bugs without having to change already written GSIMs. Moreover</span>
<span class="sd">    it performs some checks against typos.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dic</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;REQUIRES_DISTANCES&#39;</span><span class="p">:</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">KNOWN_DISTANCES</span>
                    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown distance </span><span class="si">%s</span><span class="s1"> in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="n">missing</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dic</span><span class="p">)</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">GroundShakingIntensityModel</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaGSIM</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all the ground shaking intensity models.</span>

<span class="sd">    A Ground Shaking Intensity Model (GSIM) defines a set of equations</span>
<span class="sd">    for computing mean and standard deviation of a Normal distribution</span>
<span class="sd">    representing the variability of an intensity measure (or of its logarithm)</span>
<span class="sd">    at a site given an earthquake rupture.</span>

<span class="sd">    This class is not intended to be subclassed directly, instead</span>
<span class="sd">    the actual GSIMs should subclass :class:`GMPE`</span>


<span class="sd">    Subclasses of both must implement :meth:`get_mean_and_stddevs`</span>
<span class="sd">    and all the class attributes with names starting from ``DEFINED_FOR``</span>
<span class="sd">    and ``REQUIRES``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#: Reference to a</span>
    <span class="c1">#: :class:`tectonic region type &lt;openquake.hazardlib.const.TRT&gt;` this GSIM</span>
    <span class="c1">#: is defined for. One GSIM can implement only one tectonic region type.</span>
    <span class="n">DEFINED_FOR_TECTONIC_REGION_TYPE</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="c1">#: Set of :mod:`intensity measure types &lt;openquake.hazardlib.imt&gt;`</span>
    <span class="c1">#: this GSIM can</span>
    <span class="c1">#: calculate. A set should contain classes from module</span>
    <span class="c1">#: :mod:`openquake.hazardlib.imt`.</span>
    <span class="n">DEFINED_FOR_INTENSITY_MEASURE_TYPES</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="c1">#: Reference to a :class:`intensity measure component type</span>
    <span class="c1">#: &lt;openquake.hazardlib.const.IMC&gt;` this GSIM can calculate mean</span>
    <span class="c1">#: and standard</span>
    <span class="c1">#: deviation for.</span>
    <span class="n">DEFINED_FOR_INTENSITY_MEASURE_COMPONENT</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="c1">#: Set of</span>
    <span class="c1">#: :class:`standard deviation types &lt;openquake.hazardlib.const.StdDev&gt;`</span>
    <span class="c1">#: this GSIM can calculate.</span>
    <span class="n">DEFINED_FOR_STANDARD_DEVIATION_TYPES</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="c1">#: Set of site parameters names this GSIM needs. The set should include</span>
    <span class="c1">#: strings that match names of the attributes of a :class:`site</span>
    <span class="c1">#: &lt;openquake.hazardlib.site.Site&gt;` object.</span>
    <span class="c1">#: Those attributes are then available in the</span>
    <span class="c1">#: :class:`SitesContext` object with the same names.</span>
    <span class="n">REQUIRES_SITES_PARAMETERS</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="c1">#: Set of rupture parameters (excluding distance information) required</span>
    <span class="c1">#: by GSIM. Supported parameters are:</span>
    <span class="c1">#:</span>
    <span class="c1">#: ``mag``</span>
    <span class="c1">#:     Magnitude of the rupture.</span>
    <span class="c1">#: ``dip``</span>
    <span class="c1">#:     Rupture&#39;s surface dip angle in decimal degrees.</span>
    <span class="c1">#: ``rake``</span>
    <span class="c1">#:     Angle describing the slip propagation on the rupture surface,</span>
    <span class="c1">#:     in decimal degrees. See :mod:`~openquake.hazardlib.geo.nodalplane`</span>
    <span class="c1">#:     for more detailed description of dip and rake.</span>
    <span class="c1">#: ``ztor``</span>
    <span class="c1">#:     Depth of rupture&#39;s top edge in km. See</span>
    <span class="c1">#:     :meth:`~openquake.hazardlib.geo.surface.base.BaseSurface.get_top_edge_depth`.</span>
    <span class="c1">#:</span>
    <span class="c1">#: These parameters are available from the :class:`RuptureContext` object</span>
    <span class="c1">#: attributes with same names.</span>
    <span class="n">REQUIRES_RUPTURE_PARAMETERS</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="c1">#: Set of types of distance measures between rupture and sites. Possible</span>
    <span class="c1">#: values are:</span>
    <span class="c1">#:</span>
    <span class="c1">#: ``rrup``</span>
    <span class="c1">#:     Closest distance to rupture surface.  See</span>
    <span class="c1">#:     :meth:`~openquake.hazardlib.geo.surface.base.BaseSurface.get_min_distance`.</span>
    <span class="c1">#: ``rjb``</span>
    <span class="c1">#:     Distance to rupture&#39;s surface projection. See</span>
    <span class="c1">#:     :meth:`~openquake.hazardlib.geo.surface.base.BaseSurface.get_joyner_boore_distance`.</span>
    <span class="c1">#: ``rx``</span>
    <span class="c1">#:     Perpendicular distance to rupture top edge projection.</span>
    <span class="c1">#:     See :meth:`~openquake.hazardlib.geo.surface.base.BaseSurface.get_rx_distance`.</span>
    <span class="c1">#: ``ry0``</span>
    <span class="c1">#:     Horizontal distance off the end of the rupture measured parallel to</span>
    <span class="c1">#      strike. See:</span>
    <span class="c1">#:     See :meth:`~openquake.hazardlib.geo.surface.base.BaseSurface.get_ry0_distance`.</span>
    <span class="c1">#: ``rcdpp``</span>
    <span class="c1">#:     Direct point parameter for directivity effect centered on the site- and earthquake-specific</span>
    <span class="c1">#      average DPP used. See:</span>
    <span class="c1">#:     See :meth:`~openquake.hazardlib.source.rupture.ParametricProbabilisticRupture.get_dppvalue`.</span>
    <span class="c1">#: ``rvolc``</span>
    <span class="c1">#:     Source to site distance passing through surface projection of volcanic zone</span>
    <span class="c1">#:</span>
    <span class="c1">#: All the distances are available from the :class:`DistancesContext`</span>
    <span class="c1">#: object attributes with same names. Values are in kilometers.</span>
    <span class="n">REQUIRES_DISTANCES</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">()</span>

    <span class="n">_toml</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># set by valid.gsim</span>
    <span class="n">minimum_distance</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># set by valid.gsim</span>
    <span class="n">superseded_by</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">non_verified</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">experimental</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">adapted</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">get_poes</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">get_poes</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">stddevtypes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFINED_FOR_STANDARD_DEVIATION_TYPES</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stddevtypes</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">abstractproperty</span><span class="p">):</span>  <span class="c1"># concrete class</span>
            <span class="k">if</span> <span class="n">const</span><span class="o">.</span><span class="n">StdDev</span><span class="o">.</span><span class="n">TOTAL</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stddevtypes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.DEFINED_FOR_STANDARD_DEVIATION_TYPES is &#39;</span>
                                 <span class="s1">&#39;not defined for const.StdDev.TOTAL&#39;</span> <span class="o">%</span>
                                 <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">registry</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">superseded_by</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is deprecated - use </span><span class="si">%s</span><span class="s1"> instead&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">superseded_by</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">non_verified</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not independently verified - the user is liable &#39;</span>
                   <span class="s1">&#39;for their application&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">NotVerifiedWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">experimental</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is experimental and may change in future versions - &#39;</span>
                   <span class="s1">&#39;the user is liable for their application&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ExperimentalWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">adapted</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not intended for general use and the behaviour &#39;</span>
                   <span class="s1">&#39;may not be as expected - &#39;</span>
                   <span class="s1">&#39;the user is liable for their application&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">AdaptedWarning</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_mean_and_stddevs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">rup</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">stddev_types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and return mean value of intensity distribution and it&#39;s</span>
<span class="sd">        standard deviation.</span>

<span class="sd">        Method must be implemented by subclasses.</span>

<span class="sd">        :param sites:</span>
<span class="sd">            Instance of :class:`openquake.hazardlib.site.SiteCollection`</span>
<span class="sd">            with parameters of sites</span>
<span class="sd">            collection assigned to respective values as numpy arrays.</span>
<span class="sd">            Only those attributes that are listed in class&#39;</span>
<span class="sd">            :attr:`REQUIRES_SITES_PARAMETERS` set are available.</span>
<span class="sd">        :param rup:</span>
<span class="sd">            Instance of :class:`openquake.hazardlib.source.rupture.BaseRupture`</span>
<span class="sd">            with parameters of a rupture</span>
<span class="sd">            assigned to respective values. Only those attributes that are</span>
<span class="sd">            listed in class&#39; :attr:`REQUIRES_RUPTURE_PARAMETERS` set are</span>
<span class="sd">            available.</span>
<span class="sd">        :param dists:</span>
<span class="sd">            Instance of :class:`DistancesContext` with values of distance</span>
<span class="sd">            measures between the rupture and each site of the collection</span>
<span class="sd">            assigned to respective values as numpy arrays. Only those</span>
<span class="sd">            attributes that are listed in class&#39; :attr:`REQUIRES_DISTANCES`</span>
<span class="sd">            set are available.</span>
<span class="sd">        :param imt:</span>
<span class="sd">            An instance (not a class) of intensity measure type.</span>
<span class="sd">            See :mod:`openquake.hazardlib.imt`.</span>
<span class="sd">        :param stddev_types:</span>
<span class="sd">            List of standard deviation types, constants from</span>
<span class="sd">            :class:`openquake.hazardlib.const.StdDev`.</span>
<span class="sd">            Method result value should include</span>
<span class="sd">            standard deviation values for each of types in this list.</span>

<span class="sd">        :returns:</span>
<span class="sd">            Method should return a tuple of two items. First item should be</span>
<span class="sd">            a numpy array of floats -- mean values of respective component</span>
<span class="sd">            of a chosen intensity measure type, and the second should be</span>
<span class="sd">            a list of numpy arrays of standard deviation values for the same</span>
<span class="sd">            single component of the same single intensity measure type, one</span>
<span class="sd">            array for each type in ``stddev_types`` parameter, preserving</span>
<span class="sd">            the order.</span>

<span class="sd">        Combining interface to mean and standard deviation values in a single</span>
<span class="sd">        method allows to avoid redoing the same intermediate calculations</span>
<span class="sd">        if there are some shared between stddev and mean formulae without</span>
<span class="sd">        resorting to keeping any sort of internal state (and effectively</span>
<span class="sd">        making GSIM not reenterable).</span>

<span class="sd">        However it is advised to split calculation of mean and stddev values</span>
<span class="sd">        and make ``get_mean_and_stddevs()`` just combine both (and possibly</span>
<span class="sd">        compute interim steps).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check_imt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure that ``imt`` is valid and is supported by this GSIM.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEFINED_FOR_INTENSITY_MEASURE_TYPES</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imt</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;imt </span><span class="si">%s</span><span class="s1"> is not supported by </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">imt</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The GSIMs are ordered according to string representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The GSIMs are equal if their string representations are equal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We use the __str__ representation as hash: it means that we can</span>
<span class="sd">        use equivalently GSIM instances or strings as dictionary keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation for GSIM instances in TOML format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toml</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toml</span>
        <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">def</span> <span class="nf">_truncnorm_sf</span><span class="p">(</span><span class="n">truncation_level</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Survival function for truncated normal distribution.</span>

<span class="sd">    Assumes zero mean, standard deviation equal to one and symmetric</span>
<span class="sd">    truncation.</span>

<span class="sd">    :param truncation_level:</span>
<span class="sd">        Positive float number representing the truncation on both sides</span>
<span class="sd">        around the mean, in units of sigma, or None, for non-truncation</span>
<span class="sd">    :param values:</span>
<span class="sd">        Numpy array of values as input to a survival function for the given</span>
<span class="sd">        distribution.</span>
<span class="sd">    :returns:</span>
<span class="sd">        Numpy array of survival function results in a range between 0 and 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.stats import truncnorm</span>
<span class="sd">    &gt;&gt;&gt; truncnorm(-3, 3).sf(0.12345) == _truncnorm_sf(3, 0.12345)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import norm</span>
<span class="sd">    &gt;&gt;&gt; norm.sf(0.12345) == _truncnorm_sf(None, 0.12345)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">truncation_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">if</span> <span class="n">truncation_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndtr</span><span class="p">(</span><span class="o">-</span> <span class="n">values</span><span class="p">)</span>

    <span class="c1"># notation from http://en.wikipedia.org/wiki/Truncated_normal_distribution.</span>
    <span class="c1"># given that mu = 0 and sigma = 1, we have alpha = a and beta = b.</span>

    <span class="c1"># &quot;CDF&quot; in comments refers to cumulative distribution function</span>
    <span class="c1"># of non-truncated distribution with that mu and sigma values.</span>

    <span class="c1"># assume symmetric truncation, that is ``a = - truncation_level``</span>
    <span class="c1"># and ``b = + truncation_level``.</span>

    <span class="c1"># calculate CDF of b</span>
    <span class="n">phi_b</span> <span class="o">=</span> <span class="n">ndtr</span><span class="p">(</span><span class="n">truncation_level</span><span class="p">)</span>

    <span class="c1"># calculate Z as ``Z = CDF(b) - CDF(a)``, here we assume that</span>
    <span class="c1"># ``CDF(a) == CDF(- truncation_level) == 1 - CDF(b)``</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">phi_b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># calculate the result of survival function of ``values``,</span>
    <span class="c1"># and restrict it to the interval where probability is defined --</span>
    <span class="c1"># 0..1. here we use some transformations of the original formula</span>
    <span class="c1"># that is ``SF(x) = 1 - (CDF(x) - CDF(a)) / Z`` in order to minimize</span>
    <span class="c1"># number of arithmetic operations and function calls:</span>
    <span class="c1"># ``SF(x) = (Z - CDF(x) + CDF(a)) / Z``,</span>
    <span class="c1"># ``SF(x) = (CDF(b) - CDF(a) - CDF(x) + CDF(a)) / Z``,</span>
    <span class="c1"># ``SF(x) = (CDF(b) - CDF(x)) / Z``.</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">phi_b</span> <span class="o">-</span> <span class="n">ndtr</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_distribution_values</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">imt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :returns: the logarithm of the values unless the IMT is MMI</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">imt</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;MMI&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GMPE</span><span class="p">(</span><span class="n">GroundShakingIntensityModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ground-Motion Prediction Equation is a subclass of generic</span>
<span class="sd">    :class:`GroundShakingIntensityModel` with a distinct feature</span>
<span class="sd">    that the intensity values are log-normally distributed.</span>

<span class="sd">    Method :meth:`~GroundShakingIntensityModel.get_mean_and_stddevs`</span>
<span class="sd">    of actual GMPE implementations is supposed to return the mean</span>
<span class="sd">    value as a natural logarithm of intensity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_or_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param fname_or_file: filename or filelike object</span>
<span class="sd">        :returns: the file object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fname_or_file</span><span class="p">,</span> <span class="s1">&#39;read&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fname_or_file</span>
        <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_or_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines the parameters of the GMPE provided at the construction level</span>
<span class="sd">        with the ones originally assigned to the backbone modified GMPE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ADMITTED_STR_PARAMETERS</span> <span class="o">+</span> <span class="n">ADMITTED_FLOAT_PARAMETERS</span> <span class="o">+</span>
                    <span class="n">ADMITTED_SET_PARAMETERS</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmpe</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CoeffsTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instances of :class:`CoeffsTable` encapsulate tables of coefficients</span>
<span class="sd">    corresponding to different IMTs.</span>

<span class="sd">    Tables are defined in a space-separated tabular form in a simple string</span>
<span class="sd">    literal (heading and trailing whitespace does not matter). The first column</span>
<span class="sd">    in the table must be named &quot;IMT&quot; (or &quot;imt&quot;) and thus should represent IMTs:</span>

<span class="sd">    &gt;&gt;&gt; CoeffsTable(table=&#39;&#39;&#39;imf z</span>
<span class="sd">    ...                      pga 1&#39;&#39;&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: first column in a table must be IMT</span>

<span class="sd">    Names of other columns are used as coefficients dicts keys. The values</span>
<span class="sd">    in the first column should correspond to real intensity measure types,</span>
<span class="sd">    see :mod:`openquake.hazardlib.imt`:</span>

<span class="sd">    &gt;&gt;&gt; CoeffsTable(table=&#39;&#39;&#39;imt  z</span>
<span class="sd">    ...                      pgx  2&#39;&#39;&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: unknown IMT &#39;PGX&#39;</span>

<span class="sd">    Note that :class:`CoeffsTable` only accepts keyword argumets:</span>

<span class="sd">    &gt;&gt;&gt; CoeffsTable()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: CoeffsTable requires &quot;table&quot; kwarg</span>
<span class="sd">    &gt;&gt;&gt; CoeffsTable(table=&#39;&#39;, foo=1)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: CoeffsTable got unexpected kwargs: {&#39;foo&#39;: 1}</span>

<span class="sd">    If there are :class:`~openquake.hazardlib.imt.SA` IMTs in the table, they</span>
<span class="sd">    are not referenced by name, because they require parametrization:</span>

<span class="sd">    &gt;&gt;&gt; CoeffsTable(table=&#39;&#39;&#39;imt  x</span>
<span class="sd">    ...                      sa   15&#39;&#39;&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: specify period as float value to declare SA IMT</span>
<span class="sd">    &gt;&gt;&gt; CoeffsTable(table=&#39;&#39;&#39;imt  x</span>
<span class="sd">    ...                      0.1  20&#39;&#39;&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: attribute &quot;sa_damping&quot; is required for tables defining SA</span>

<span class="sd">    So proper table defining SA looks like this:</span>

<span class="sd">    &gt;&gt;&gt; ct = CoeffsTable(sa_damping=5, table=&#39;&#39;&#39;</span>
<span class="sd">    ...     imt   a    b     c   d</span>
<span class="sd">    ...     pga   1    2.4  -5   0.01</span>
<span class="sd">    ...     pgd  7.6  12     0  44.1</span>
<span class="sd">    ...     0.1  10   20    30  40</span>
<span class="sd">    ...     1.0   1    2     3   4</span>
<span class="sd">    ...     10    2    4     6   8</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>

<span class="sd">    Table objects could be indexed by IMT objects (this returns a dictionary</span>
<span class="sd">    of coefficients):</span>

<span class="sd">    &gt;&gt;&gt; from openquake.hazardlib import imt</span>
<span class="sd">    &gt;&gt;&gt; ct[imt.PGA()] == dict(a=1, b=2.4, c=-5, d=0.01)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ct[imt.PGD()] == dict(a=7.6, b=12, c=0, d=44.1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ct[imt.SA(damping=5, period=0.1)] == dict(a=10, b=20, c=30, d=40)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ct[imt.PGV()]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    KeyError: PGV</span>
<span class="sd">    &gt;&gt;&gt; ct[imt.SA(1.0, 4)]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    KeyError: SA(1.0, 4)</span>

<span class="sd">    Table of coefficients for spectral acceleration could be indexed</span>
<span class="sd">    by instances of :class:`openquake.hazardlib.imt.SA` with period</span>
<span class="sd">    value that is not specified in the table. The coefficients then</span>
<span class="sd">    get interpolated between the ones for closest higher and closest</span>
<span class="sd">    lower period. That scaling of coefficients works in a logarithmic</span>
<span class="sd">    scale of periods and only within the same damping:</span>

<span class="sd">    &gt;&gt;&gt; &#39;%.5f&#39; % ct[imt.SA(period=0.2, damping=5)][&#39;a&#39;]</span>
<span class="sd">    &#39;7.29073&#39;</span>
<span class="sd">    &gt;&gt;&gt; &#39;%.5f&#39; % ct[imt.SA(period=0.9, damping=5)][&#39;c&#39;]</span>
<span class="sd">    &#39;4.23545&#39;</span>
<span class="sd">    &gt;&gt;&gt; &#39;%.5f&#39; % ct[imt.SA(period=5, damping=5)][&#39;c&#39;]</span>
<span class="sd">    &#39;5.09691&#39;</span>
<span class="sd">    &gt;&gt;&gt; ct[imt.SA(period=0.9, damping=15)]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    KeyError: SA(0.9, 15)</span>

<span class="sd">    Extrapolation is not possible:</span>

<span class="sd">    &gt;&gt;&gt; ct[imt.SA(period=0.01, damping=5)]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    KeyError: SA(0.01)</span>

<span class="sd">    It is also possible to instantiate a table from a tuple of dictionaries,</span>
<span class="sd">    corresponding to the SA coefficients and non-SA coefficients:</span>

<span class="sd">    &gt;&gt;&gt; coeffs = {imt.SA(0.1): {&quot;a&quot;: 1.0, &quot;b&quot;: 2.0},</span>
<span class="sd">    ...           imt.SA(1.0): {&quot;a&quot;: 3.0, &quot;b&quot;: 4.0},</span>
<span class="sd">    ...           imt.PGA(): {&quot;a&quot;: 0.1, &quot;b&quot;: 1.0},</span>
<span class="sd">    ...           imt.PGV(): {&quot;a&quot;: 0.5, &quot;b&quot;: 10.0}}</span>
<span class="sd">    &gt;&gt;&gt; ct = CoeffsTable(sa_damping=5, table=coeffs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_instances</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;CoeffsTable requires &quot;table&quot; kwarg&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># cache</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;table&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_sa_coeffs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sa_damping</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sa_damping&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;CoeffsTable got unexpected kwargs: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_table_from_str</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">sa_damping</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">imt</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">imt</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;SA&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">non_sa_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;CoeffsTable cannot be constructed with inputs &quot;</span>
                            <span class="s2">&quot;of the form &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">table</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">num_instances</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_setup_table_from_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">sa_damping</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the input tables from a string definition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;IMT&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;first column in a table must be IMT&#39;</span><span class="p">)</span>
        <span class="n">coeff_names</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">imt_name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">imt_name</span> <span class="o">==</span> <span class="s1">&#39;SA&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;specify period as float value &#39;</span>
                                 <span class="s1">&#39;to declare SA IMT&#39;</span><span class="p">)</span>
            <span class="n">imt_coeffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sa_period</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">imt_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">imt_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">imt_module</span><span class="o">.</span><span class="n">registry</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown IMT </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">imt_name</span><span class="p">)</span>
                <span class="n">imt</span> <span class="o">=</span> <span class="n">imt_module</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">imt_name</span><span class="p">]()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">non_sa_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">imt_coeffs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sa_damping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;attribute &quot;sa_damping&quot; is required &#39;</span>
                                    <span class="s1">&#39;for tables defining SA&#39;</span><span class="p">)</span>
                <span class="n">imt</span> <span class="o">=</span> <span class="n">imt_module</span><span class="o">.</span><span class="n">SA</span><span class="p">(</span><span class="n">sa_period</span><span class="p">,</span> <span class="n">sa_damping</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">imt_coeffs</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of coefficients corresponding to ``imt``</span>
<span class="sd">        from this table (if there is a line for requested IMT in it),</span>
<span class="sd">        or the dictionary of interpolated coefficients, if ``imt`` is</span>
<span class="sd">        of type :class:`~openquake.hazardlib.imt.SA` and interpolation</span>
<span class="sd">        is possible.</span>

<span class="sd">        :raises KeyError:</span>
<span class="sd">            If ``imt`` is not available in the table and no interpolation</span>
<span class="sd">            can be done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">imt</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;SA&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_sa_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">max_below</span> <span class="o">=</span> <span class="n">min_above</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">unscaled_imt</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">unscaled_imt</span><span class="o">.</span><span class="n">damping</span> <span class="o">!=</span> <span class="n">imt</span><span class="o">.</span><span class="n">damping</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">unscaled_imt</span><span class="o">.</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">imt</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">min_above</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unscaled_imt</span><span class="o">.</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">min_above</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
                    <span class="n">min_above</span> <span class="o">=</span> <span class="n">unscaled_imt</span>
            <span class="k">elif</span> <span class="n">unscaled_imt</span><span class="o">.</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">imt</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">max_below</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unscaled_imt</span><span class="o">.</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">max_below</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
                    <span class="n">max_below</span> <span class="o">=</span> <span class="n">unscaled_imt</span>
        <span class="k">if</span> <span class="n">max_below</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_above</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">imt</span><span class="p">)</span>

        <span class="c1"># ratio tends to 1 when target period tends to a minimum</span>
        <span class="c1"># known period above and to 0 if target period is close</span>
        <span class="c1"># to maximum period below.</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">imt</span><span class="o">.</span><span class="n">period</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">max_below</span><span class="o">.</span><span class="n">period</span><span class="p">))</span>
                 <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">min_above</span><span class="o">.</span><span class="n">period</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">max_below</span><span class="o">.</span><span class="n">period</span><span class="p">)))</span>
        <span class="n">max_below</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span><span class="p">[</span><span class="n">max_below</span><span class="p">]</span>
        <span class="n">min_above</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa_coeffs</span><span class="p">[</span><span class="n">min_above</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coeffs</span><span class="p">[</span><span class="n">imt</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">co</span><span class="p">:</span> <span class="p">(</span><span class="n">min_above</span><span class="p">[</span><span class="n">co</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_below</span><span class="p">[</span><span class="n">co</span><span class="p">])</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">+</span> <span class="n">max_below</span><span class="p">[</span><span class="n">co</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">co</span> <span class="ow">in</span> <span class="n">max_below</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">c</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../index.html">
    <img class="logo" src="../../../../_static/northridge_thumbnail_light_16x9.png" alt="Logo"/>
    
    <h1 class="logo logo-name">ShakeMap Documentation</h1>
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../manual4_0/index.html">ShakeMap 4.0 Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../programs/programs.html">ShakeMap 4.0 Command Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apidoc/shakemap.html">ShakeMap 4.0 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../manual3_5/index.html">ShakeMap 3.5 Manual (Deprecated)</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
    </div>

    

    
  </body>
</html>