
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>shakelib.directivity.bayless2013 &#8212; ShakeMap Documentation  documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for shakelib.directivity.bayless2013</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">openquake.hazardlib.geo</span> <span class="k">as</span> <span class="nn">geo</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">shakelib.distance</span> <span class="kn">import</span> <span class="n">get_distance</span>
<span class="kn">from</span> <span class="nn">shakelib.rupture.utils</span> <span class="kn">import</span> <span class="n">_distance_sq_to_segment</span>
<span class="kn">import</span> <span class="nn">impactutils.vectorutils.ecef</span> <span class="k">as</span> <span class="nn">ecef</span>
<span class="kn">from</span> <span class="nn">impactutils.vectorutils.vector</span> <span class="kn">import</span> <span class="n">Vector</span>


<div class="viewcode-block" id="Bayless2013"><a class="viewcode-back" href="../../../shakelib/shakelib.directivity.bayless2013.html#shakelib.directivity.bayless2013.Bayless2013">[docs]</a><span class="k">class</span> <span class="nc">Bayless2013</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the Bayless and Somerville (2013) directivity model. This is an</span>
<span class="sd">    update to Somerville et al. (1997), which defines some of the input</span>
<span class="sd">    parameters.</span>

<span class="sd">    Fd is the directivity effect parameter, and it is evaluated as</span>

<span class="sd">    Fd = (c0 + c1 * Fgeom) * Tcd * Tmw * Taz</span>

<span class="sd">    Note that Fd is intended to be used in GMPEs as:</span>

<span class="sd">    ln(IM_dir) = ln(IM) + Fd</span>

<span class="sd">    where</span>

<span class="sd">    - Fd is the directivity effect</span>
<span class="sd">    - IM is the intensity measure predicted by the GMPE.</span>
<span class="sd">    - IM_dir is the directivity-adjusted IM.</span>

<span class="sd">    The model is seprated into strike-slip and dip-slip categories:</span>
<span class="sd">    SS: (abs(rake) &gt;  0 &amp; abs(rake) &lt; 30) | (abs(rake) &gt; 150 &amp; abs(rake) &lt; 180)</span>
<span class="sd">    DS:  abs(rake) &gt; 60 &amp; abs(rake) &lt; 120</span>

<span class="sd">    Notes from Somerville et al. (1997):</span>

<span class="sd">    * d = length of dipping fault rupturing towards site</span>
<span class="sd">    * Y = d/W</span>
<span class="sd">    * s = length of striking fault rupturing towards site</span>
<span class="sd">    * X = s/L</span>

<span class="sd">    Bayless and Somerville state that each quadrilateral should have a pseudo-</span>
<span class="sd">    hypocenter:</span>

<span class="sd">        &quot;Define the pseudo-hypocenter for rupture of successive segments as the</span>
<span class="sd">        point on the side edge of the fault segment that is closest to the side</span>
<span class="sd">        edge of the previous segment, and that lies half way between the top</span>
<span class="sd">        and bottom of the fault. We assume that the fault is segmented along</span>
<span class="sd">        strike, not updip. All geometric parameters are computed relative to</span>
<span class="sd">        the pseudo-hypocenter.&quot;</span>

<span class="sd">    To do:</span>

<span class="sd">        - Interpolate for arbitrary periods</span>
<span class="sd">        - Inherit from Directivity base class.</span>

<span class="sd">    References:</span>
<span class="sd">        Bayless, J., and Somerville, P. (2013). Bayless-Somerville Directivity</span>
<span class="sd">        Model, Chapter 3 of PEER Report No. 2013/09, P. Spudich (Editor),</span>
<span class="sd">        Pacific Earthquake Engineering Research Center, Berkeley, CA.</span>
<span class="sd">        `[link] &lt;http://peer.berkeley.edu/publications/peer_reports/reports_2013/webPEER-2013-09-Spudich.pdf&gt;`__</span>

<span class="sd">        Somerville, P. G., Smith, N. F., Graves, R. W., and Abrahamson, N. A.</span>
<span class="sd">        (1997). Modification of empirical strong ground motion attenuation</span>
<span class="sd">        relations to include the amplitude and duration effects of rupture</span>
<span class="sd">        directivity, Seismol. Res. Lett. 68, 199â€“222.</span>
<span class="sd">        `[link] &lt;http://srl.geoscienceworld.org/content/68/1/199.abstract&gt;`__</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># C0 adn C1 are for RotD50. One set for each mechanism (SS vs DS).</span>
    <span class="c1"># FN and FP are also available</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="n">__periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
    <span class="n">__c0ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.12</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.175</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.21</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.235</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.255</span><span class="p">,</span>
                       <span class="o">-</span><span class="mf">0.275</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.29</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">])</span>
    <span class="n">__c1ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.075</span><span class="p">,</span> <span class="mf">0.090</span><span class="p">,</span> <span class="mf">0.095</span><span class="p">,</span> <span class="mf">0.099</span><span class="p">,</span> <span class="mf">0.103</span><span class="p">,</span> <span class="mf">0.108</span><span class="p">,</span>
                       <span class="mf">0.112</span><span class="p">,</span> <span class="mf">0.115</span><span class="p">])</span>
    <span class="n">__c0ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.089</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.133</span><span class="p">,</span>
                       <span class="o">-</span><span class="mf">0.16</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.176</span><span class="p">])</span>
    <span class="n">__c1ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.034</span><span class="p">,</span> <span class="mf">0.093</span><span class="p">,</span> <span class="mf">0.128</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span>
                       <span class="mf">0.165</span><span class="p">,</span> <span class="mf">0.179</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">rup</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for bayless2013.</span>

<span class="sd">        Args:</span>
<span class="sd">            origin: Shakemap Origin object.</span>
<span class="sd">            rup: Shakemap Rupture object.</span>
<span class="sd">            lat: Numpy array of latitudes.</span>
<span class="sd">            lon: Numpy array of longitudes.</span>
<span class="sd">            depth: Numpy array of depths (km); down is positive.</span>
<span class="sd">            T: Period; Currently, only acceptable values are</span>
<span class="sd">                0.5, 0.75, 1, 1.5, 2, 3, 4, 5, 7.5, 10.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span> <span class="o">=</span> <span class="n">rup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rake</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">rake</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">mag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hyp</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">getHypo</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span> <span class="o">=</span> <span class="n">lon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span> <span class="o">=</span> <span class="n">lat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dep</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">T</span>

        <span class="c1"># Lists of widths and lengths for each quad in the rupture</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span><span class="o">.</span><span class="n">getIndividualWidths</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span><span class="o">.</span><span class="n">getIndividualTopLengths</span><span class="p">()</span>

        <span class="c1"># Number of quads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">)</span>

        <span class="c1"># Currently assuming that the rake is the same on all subruptures .</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__getSlipCategory</span><span class="p">()</span>

        <span class="c1"># Rupture weights are supposed to be based on seismic moment.</span>
        <span class="c1"># Since moment is proportional to area, lets just use area</span>
        <span class="c1"># for now</span>
        <span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

        <span class="c1"># Put in pseudo-hypocenters for each quad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setPseudoHypocenters</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nq</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1"># Compute some genral stuff that is required for all mechanisms</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rrup&#39;</span><span class="p">,</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="s1">&#39;ry0&#39;</span><span class="p">]</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">get_distance</span><span class="p">(</span><span class="n">dtypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dep</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="s1">&#39;rrup&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__Rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__Ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="s1">&#39;ry0&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># NOTE: use Rx and Ry to compute Az in &#39;computeAz&#39;. It is probably</span>
            <span class="c1">#       possible to make this a lot faster by avoiding the</span>
            <span class="c1">#       calculation of these distances each time.</span>

            <span class="c1"># Az is the NGA definition of source-to-site azimuth for a finite</span>
            <span class="c1"># rupture. See Kaklamanos et al. (2011) Figure 2 for illustration.</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__computeAz</span><span class="p">()</span>  <span class="c1"># uses Rx and Ry, which are for the i-th quad.</span>

            <span class="c1"># Magnitude taper (does not depend on mechanism)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">&lt;=</span> <span class="mf">5.0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_T_Mw</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">&gt;</span> <span class="mf">5.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">&lt;</span> <span class="mf">6.5</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_T_Mw</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="mf">6.5</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_T_Mw</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SlipCategory</span> <span class="o">==</span> <span class="s1">&#39;SS&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__computeSS</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_SS</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SlipCategory</span> <span class="o">==</span> <span class="s1">&#39;DS&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__computeDS</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_DS</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Compute both SS and DS</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__computeSS</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__computeDS</span><span class="p">()</span>

                <span class="c1"># Normalize rake to reference angle</span>
                <span class="n">sintheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rake</span><span class="p">)))</span>
                <span class="n">costheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rake</span><span class="p">)))</span>
                <span class="n">refrake</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sintheta</span><span class="p">,</span> <span class="n">costheta</span><span class="p">)</span>

                <span class="c1"># Compute weights:</span>
                <span class="n">DipWeight</span> <span class="o">=</span> <span class="n">refrake</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
                <span class="n">StrikeWeight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">DipWeight</span>
                <span class="n">fdcombined</span> <span class="o">=</span> <span class="n">StrikeWeight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_SS</span> <span class="o">+</span> <span class="n">DipWeight</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_fd_DS</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fdcombined</span>

    <span class="k">def</span> <span class="nf">__setPseudoHypocenters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set a pseudo-hypocenter.</span>

<span class="sd">        Adapted from ShakeMap 3.5 src/contour/directivity.c</span>

<span class="sd">        From Bayless and Somerville:</span>

<span class="sd">        &quot;Define the pseudo-hypocenter for rupture of successive segments as</span>
<span class="sd">        the point on the side edge of the rupture segment that is closest to</span>
<span class="sd">        the side edge of the previous segment, and that lies half way</span>
<span class="sd">        between the top and bottom of the rupture. We assume that the rupture</span>
<span class="sd">        is segmented along strike, not updip. All geometric parameters are</span>
<span class="sd">        computed relative to the pseudo-hypocenter.&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hyp_ecef</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hyp</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyp</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hyp</span><span class="o">.</span><span class="n">depth</span><span class="p">))</span>
        <span class="c1"># Loop over each quad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nq</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nq</span><span class="p">):</span>
            <span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span><span class="o">.</span><span class="n">getQuadrilaterals</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>  <span class="c1"># convert to ECEF</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P3</span><span class="p">)</span>

            <span class="c1"># Create 4 planes with normals pointing outside rectangle</span>
            <span class="n">hpnp</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
            <span class="n">hpp</span> <span class="o">=</span> <span class="o">-</span><span class="n">hpnp</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">hpnp</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">hpnp</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">z</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">,</span> <span class="n">hpnp</span><span class="p">)</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">,</span> <span class="n">hpnp</span><span class="p">)</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p3</span> <span class="o">-</span> <span class="n">p2</span><span class="p">,</span> <span class="n">hpnp</span><span class="p">)</span>
            <span class="n">n3</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p0</span> <span class="o">-</span> <span class="n">p3</span><span class="p">,</span> <span class="n">hpnp</span><span class="p">)</span>

            <span class="c1"># -----------------------------------------------------------------</span>
            <span class="c1"># Is the hypocenter inside the projected rectangle?</span>
            <span class="c1"># Dot products show which side the origin is on.</span>
            <span class="c1"># If origin is on same side of all the planes, then it is &#39;inside&#39;</span>
            <span class="c1"># -----------------------------------------------------------------</span>

            <span class="n">sgn0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="p">))</span>
            <span class="n">sgn1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="p">))</span>
            <span class="n">sgn2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="p">))</span>
            <span class="n">sgn3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n3</span><span class="p">,</span> <span class="n">p3</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="p">))</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">sgn0</span> <span class="o">==</span> <span class="n">sgn1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sgn1</span> <span class="o">==</span> <span class="n">sgn2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sgn2</span> <span class="o">==</span> <span class="n">sgn3</span><span class="p">):</span>
                <span class="c1"># Origin is inside. Use distance-to-plane formula.</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hpnp</span><span class="p">,</span> <span class="n">hyp_ecef</span><span class="p">)</span> <span class="o">+</span> <span class="n">hpp</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span>

                <span class="c1"># Put the pseudo hypocenter on the plane</span>
                <span class="n">D</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hpnp</span><span class="p">,</span> <span class="n">hyp_ecef</span><span class="p">)</span> <span class="o">+</span> <span class="n">hpp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hyp_ecef</span> <span class="o">-</span> <span class="n">hpnp</span> <span class="o">*</span> <span class="n">D</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Origin is outside. Find distance to edges</span>
                <span class="n">p0p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="o">.</span><span class="n">getArray</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">p1p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="o">.</span><span class="n">getArray</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">p2p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="o">.</span><span class="n">getArray</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">p3p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p3</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span> <span class="o">-</span> <span class="n">hyp_ecef</span><span class="o">.</span><span class="n">getArray</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">_distance_sq_to_segment</span><span class="p">(</span><span class="n">p1p</span><span class="p">,</span> <span class="n">p2p</span><span class="p">)</span>
                <span class="n">s3</span> <span class="o">=</span> <span class="n">_distance_sq_to_segment</span><span class="p">(</span><span class="n">p3p</span><span class="p">,</span> <span class="n">p0p</span><span class="p">)</span>

                <span class="c1"># Assuming that the rupture is segmented along strike and not</span>
                <span class="c1"># updip (as described by Bayless and somerville), we only</span>
                <span class="c1"># need to consider s1 and s3:</span>
                <span class="k">if</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s3</span><span class="p">:</span>
                    <span class="n">e30</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">p3</span>
                    <span class="n">e30norm</span> <span class="o">=</span> <span class="n">e30</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
                    <span class="n">mag</span> <span class="o">=</span> <span class="n">e30</span><span class="o">.</span><span class="n">mag</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span> <span class="o">+</span> <span class="n">e30norm</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">mag</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e21</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>
                    <span class="n">e21norm</span> <span class="o">=</span> <span class="n">e21</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
                    <span class="n">mag</span> <span class="o">=</span> <span class="n">e21</span><span class="o">.</span><span class="n">mag</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">+</span> <span class="n">e21norm</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">mag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__computeDS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># d is the length of dipping rupture rupturing toward site;</span>
        <span class="c1"># Note: max[(Y*W),exp(0)] -- just apply a min of 1?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__computeD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Geometric directivity predictor:</span>
        <span class="n">RxoverW</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rx</span> <span class="o">/</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
            <span class="nb">min</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
        <span class="n">f_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">RxoverW</span><span class="p">)</span>

        <span class="c1"># Distance taper</span>
        <span class="n">T_CD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">)</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="p">)])</span>
        <span class="n">T_CD</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.5</span>
        <span class="n">T_CD</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">2.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Azimuth taper</span>
        <span class="n">T_Az</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Az</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Select Coefficients</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__periods</span><span class="p">])</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__c0ds</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__c1ds</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fd_DS</span> <span class="o">=</span> <span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">*</span> <span class="n">f_geom</span><span class="p">)</span> <span class="o">*</span> <span class="n">T_CD</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T_Mw</span> <span class="o">*</span> <span class="n">T_Az</span>

    <span class="k">def</span> <span class="nf">__computeSS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># s is the length of striking fault rupturing toward site;</span>
        <span class="c1"># max[(X*L),exp(1)]</span>
        <span class="c1"># theta (see Figure 5 in SSGA97)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__computeThetaAndS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Geometric directivity predictor:</span>
        <span class="n">f_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Distance taper</span>
        <span class="n">T_CD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">/</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">[</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">/</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)])</span>
        <span class="n">T_CD</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.5</span>
        <span class="n">T_CD</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rrup</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Azimuth taper</span>
        <span class="n">T_Az</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Select Coefficients</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__periods</span><span class="p">])</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__c0ss</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__c1ss</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fd_SS</span> <span class="o">=</span> <span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">*</span> <span class="n">f_geom</span><span class="p">)</span> <span class="o">*</span> <span class="n">T_CD</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T_Mw</span> <span class="o">*</span> <span class="n">T_Az</span>

    <span class="k">def</span> <span class="nf">__computeAz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Az</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rx</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">Az</span> <span class="o">=</span> <span class="n">Az</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rx</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__Ry</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="n">Az</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Rx</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__Ry</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Az</span> <span class="o">=</span> <span class="n">Az</span>

    <span class="k">def</span> <span class="nf">__computeD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute d for the i-th quad/segment.</span>

<span class="sd">        Y = d/W, where d is the portion (in km) of the width of the fault which</span>
<span class="sd">        ruptures up-dip from the hypocenter to the top of the fault.</span>

<span class="sd">        Args:</span>
<span class="sd">            i (int): index of segment for which d is to be computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hyp_ecef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># already in ECEF</span>
        <span class="n">hyp_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">hyp_ecef</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">hyp_ecef</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">hyp_ecef</span><span class="o">.</span><span class="n">z</span><span class="p">]])</span>

        <span class="c1"># First compute &quot;updip&quot; vector</span>
        <span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span><span class="o">.</span><span class="n">getQuadrilaterals</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>  <span class="c1"># convert to ECEF</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
        <span class="n">e21</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>
        <span class="n">e21norm</span> <span class="o">=</span> <span class="n">e21</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">hp1</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">hyp_ecef</span>
        <span class="c1"># convert to km (used as max later)</span>
        <span class="n">udip_len</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hp1</span><span class="p">,</span> <span class="n">e21norm</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">udip_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">e21norm</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">e21norm</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">e21norm</span><span class="o">.</span><span class="n">z</span><span class="p">]])</span>  <span class="c1"># ECEF coords</span>

        <span class="c1"># Sites</span>
        <span class="n">slat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span>
        <span class="n">slon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span>

        <span class="c1"># Convert sites to ECEF:</span>
        <span class="n">site_ecef_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">slat</span><span class="p">)</span>
        <span class="n">site_ecef_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">slat</span><span class="p">)</span>
        <span class="n">site_ecef_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">slat</span><span class="p">)</span>

        <span class="c1"># Make a 3x(#number of sites) matrix of site locations</span>
        <span class="c1"># (rows are x, y, z) in ECEF</span>
        <span class="n">site_ecef_x</span><span class="p">,</span> <span class="n">site_ecef_y</span><span class="p">,</span> <span class="n">site_ecef_z</span> <span class="o">=</span> <span class="n">ecef</span><span class="o">.</span><span class="n">latlon2ecef</span><span class="p">(</span>
            <span class="n">slat</span><span class="p">,</span> <span class="n">slon</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">slon</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">site_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">site_ecef_x</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">site_ecef_y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">site_ecef_z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))])</span>

        <span class="c1"># Hypocenter-to-site matrix</span>
        <span class="n">h2s_mat</span> <span class="o">=</span> <span class="n">site_mat</span> <span class="o">-</span> <span class="n">hyp_col</span>  <span class="c1"># in ECEF</span>

        <span class="c1"># Dot hypocenter-to-site with updip vector</span>
        <span class="n">d_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h2s_mat</span> <span class="o">*</span> <span class="n">udip_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> \
            <span class="mf">1000.0</span>  <span class="c1"># convert to km</span>
        <span class="n">d_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d_raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d_raw</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">udip_len</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__computeThetaAndS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            i (int): Compute d for the i-th quad/segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># self.phyp is in ECEF</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">ecef</span><span class="o">.</span><span class="n">ecef2latlon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phyp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">epi_ecef</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">geo</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="n">epi_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">epi_ecef</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">epi_ecef</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">epi_ecef</span><span class="o">.</span><span class="n">z</span><span class="p">]])</span>

        <span class="c1"># First compute along strike vector</span>
        <span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">P3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rup</span><span class="o">.</span><span class="n">getQuadrilaterals</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P0</span><span class="p">)</span>  <span class="c1"># convert to ECEF</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">fromPoint</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
        <span class="n">e01</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span>
        <span class="n">e01norm</span> <span class="o">=</span> <span class="n">e01</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">hp0</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">epi_ecef</span>
        <span class="n">hp1</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">epi_ecef</span>
        <span class="n">strike_min</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hp0</span><span class="p">,</span> <span class="n">e01norm</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># convert to km</span>
        <span class="n">strike_max</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hp1</span><span class="p">,</span> <span class="n">e01norm</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># convert to km</span>
        <span class="n">strike_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">e01norm</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">e01norm</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">e01norm</span><span class="o">.</span><span class="n">z</span><span class="p">]])</span>  <span class="c1"># ECEF coords</span>

        <span class="c1"># Sites</span>
        <span class="n">slat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span>
        <span class="n">slon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span>

        <span class="c1"># Convert sites to ECEF:</span>
        <span class="n">site_ecef_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">slat</span><span class="p">)</span>
        <span class="n">site_ecef_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">slat</span><span class="p">)</span>
        <span class="n">site_ecef_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">slat</span><span class="p">)</span>

        <span class="c1"># Make a 3x(#number of sites) matrix of site locations</span>
        <span class="c1"># (rows are x, y, z) in ECEF</span>
        <span class="n">site_ecef_x</span><span class="p">,</span> <span class="n">site_ecef_y</span><span class="p">,</span> <span class="n">site_ecef_z</span> <span class="o">=</span> <span class="n">ecef</span><span class="o">.</span><span class="n">latlon2ecef</span><span class="p">(</span>
            <span class="n">slat</span><span class="p">,</span> <span class="n">slon</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">slon</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">site_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">site_ecef_x</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">site_ecef_y</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">site_ecef_z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))])</span>

        <span class="c1"># Epicenter-to-site matrix</span>
        <span class="n">e2s_mat</span> <span class="o">=</span> <span class="n">site_mat</span> <span class="o">-</span> <span class="n">epi_col</span>  <span class="c1"># in ECEF</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e2s_mat</span> <span class="o">*</span> <span class="n">e2s_mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Avoid division by zero</span>
        <span class="n">mag</span><span class="p">[</span><span class="n">mag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-12</span>
        <span class="n">e2s_norm</span> <span class="o">=</span> <span class="n">e2s_mat</span> <span class="o">/</span> <span class="n">mag</span>

        <span class="c1"># Dot epicenter-to-site with along-strike vector</span>
        <span class="n">s_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e2s_mat</span> <span class="o">*</span> <span class="n">strike_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># conver to km</span>

        <span class="c1"># Put back into a 2d array</span>
        <span class="n">s_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s_raw</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">strike_min</span><span class="p">,</span>
                                   <span class="nb">max</span><span class="o">=</span><span class="n">strike_max</span><span class="p">))</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Compute theta</span>
        <span class="n">sdots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e2s_norm</span> <span class="o">*</span> <span class="n">strike_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">theta_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">sdots</span><span class="p">)</span>

        <span class="c1"># But theta is defined to be the reference angle</span>
        <span class="c1"># (i.e., the equivalent angle between 0 and 90 deg)</span>
        <span class="n">sintheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_raw</span><span class="p">))</span>
        <span class="n">costheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_raw</span><span class="p">))</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sintheta</span><span class="p">,</span> <span class="n">costheta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="Bayless2013.getFd"><a class="viewcode-back" href="../../../shakelib/shakelib.directivity.bayless2013.html#shakelib.directivity.bayless2013.Bayless2013.getFd">[docs]</a>    <span class="k">def</span> <span class="nf">getFd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Numpy array of Fd; Fd is the directivity amplification factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fd</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getSlipCategory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets self.SlipCategory based on rake angle. Can be SS for</span>
<span class="sd">        strike slip, DS for dip slip, or Unspecified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arake</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rake</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SlipCategory</span> <span class="o">=</span> <span class="s1">&#39;Unspecified&#39;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">arake</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">arake</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">arake</span> <span class="o">&gt;=</span> <span class="mi">150</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">arake</span> <span class="o">&lt;=</span> <span class="mi">180</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SlipCategory</span> <span class="o">=</span> <span class="s1">&#39;SS&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arake</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">arake</span> <span class="o">&lt;=</span> <span class="mi">120</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SlipCategory</span> <span class="o">=</span> <span class="s1">&#39;DS&#39;</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/northridge_thumbnail_light_16x9.png" alt="Logo"/>
    
    <h1 class="logo logo-name">ShakeMap Documentation</h1>
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../manual4_0/index.html">ShakeMap 4.0 Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../programs/programs.html">ShakeMap 4.0 Command Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apidoc/shakemap.html">ShakeMap 4.0 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manual3_5/index.html">ShakeMap 3.5 Manual (Deprecated)</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
    </div>

    

    
  </body>
</html>